## The following two functions [makeCacheMatrix, cacheSolve] can be utilized to "cache" the results of an inverse
## of a matrix (i.e. stored in as an R object in memory). This is useful as the calculating the inverse of a 
## matrix can be compute intensive.
##
## The user must first invoke the [makeCacheMatrix] function inorder to produce a R object that the [cacheSolve] 
## can utilize, as the [cacheSolve] relies the user-defined R object generated by [makeCacheMatrix]. The [makeCacheMatrix]
## produces a list of four fucntions:
##    1. set: Stores the variable passed [y] into [x] and sets variable [inv] to NULL. It should be noted that the within 
##            the function variables are assigned with [<<-] as opposed to [<-].  The [<<-] operater is "used to assign a 
##            value to an object in an environment different than the current environment.
##
##            TLDR: When called, the matrix object is stored as [x] in a different environment (or "cached" environment) and
##            the calculated matrix [inv] is set to NULL (or empty) in the "cached" environment.
##    2. get: Returns [x] from the "cached" environment.
##            This function suggests that sub functions (functions created within the [makeCacheMatrix] function), have the same
##            child environment, which is why you are able to retrieve [x] in this manner.
##    3. setinverse: Sets the results of the inverse matrix based on the R object [solve] into the [inv] in the "cached" 
##            environment. Also the purpsoe of naming the varaible "solve" which is also the name of the function, is to 
##            demonstrate that variables and functions can share the same name. The function can be written as:
##            setinverse <<- function(inversed_matrix) inv <<- inversed_matrix
##    4. getinverse: Returns [inv] from the "cached" envrionment.
##
## Finally the list of functions is returned. For example "set = set" means that the set function as defined in this function is
## given the object name of set (Need to confirm. That is, would the fucniton work if instead of "set = set" we had "fset = set"?)
##
## The assignment is meant to show that a variable of the same name can preserve two different variables, as they are in two different
## environments (i.e. lexical scoping).
##
## To see whether this will work, two examples of matrices are provided below
## m1 <- rbind(c(2, 1, 1), c(3, 2, 1), c(2, 1, 2)) #This example use as the inverse is a known value (thank you internet!)
## See inverse of m1 below
##             [,1] [,2] [,3]
##        [1,]    3   -1   -1
##        [2,]   -4    2    1
##        [3,]   -1    0    1
## m2 <- matrix(1:4, 2, 2)

makeCacheMatrix <- function(x = matrix()) {
  inv <- NULL
  
  set <- function(y) {
    x <<- y
    inv <<- NULL
    message("x cached")  ##unclear why this doesn't get executed...Does this ever get executed?
  }
  
  get <- function() x
  setinverse <- function(solve) inv <<- solve
  #setinverse <- function(matrix_inv) inv <<- matrix_inv
  getinverse <- function() inv
  

  list (set = set, get = get, setinverse = setinverse, getinverse = getinverse)
}


## The [cacheSolve] function will either
##    1. Return the cached matrix inverse or
##    2. Calculate the inverse and store the results in "cache"
##
## The function expects an R object based on the makeCachMatrix function.

cacheSolve <- function(x, ...) {
  ## Calls the getinverse function from x (R object passed to this function)
  ## When this is called for the first time, we note that [inv] in the "cache" environment hasn't been set. Since, it hasn't
  ## been set, it will then go to the parent environment to grab what [inv] should return. This is why you have the statement
  ## inv <- 1 (This can be tested by commenting out the first line of function [makeCacheMatrix]).
  ##
  ## If the inverse have been calculated for this object, it just returns the "cached" value
  inv <- x$getinverse()
  if(!is.null(inv)) {
    message("getting cached data")
    return(inv)
  }
  
  ## If it get's this far into the function, we know that the inverse has not been calculated. So the following steps are taken;
  ##    1. R object [data] retrieves the matrix
  ##    2. Calculates the inverse using the solve() function
  ##    3. Sets the "cached" [inv] R object with the setinverse function
  data <- x$get()
  inv <- solve(data, ...)
  x$setinverse(inv)
  
  ## Returns matrix inverse
  inv
}


